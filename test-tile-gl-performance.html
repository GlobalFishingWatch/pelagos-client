<!doctype html>
<html>
  <head>
    <title>VectorVisual</title>

    <script type="text/shader" id="vertex-shader">
      attribute float latitude;
      attribute float longitude;

      attribute float category;
      attribute float datetime;
      attribute float interval;
      attribute float score;
      attribute float series;
      attribute float rowidx;
 

      varying vec3 vColor;

      void main(void) {
        float dummy = (category + datetime + interval + score + series + rowidx);
        if (longitude < 400.0) dummy = dummy * 0.0;

        gl_Position = vec4(longitude / 180.0, latitude / 90.0, dummy, 1.0);
        gl_PointSize = 5.0;
        vColor=vec3(1.0, 0.5, 0.0);
      }
    </script>
 
    <script type="text/shader" id="fragment-shader">
      precision mediump float;
 
      varying vec3 vColor;
 
      void main(void) {
        gl_FragColor = vec4(vColor, 1.);
      }
    </script>

    <script type="text/javascript">
      app = {
        useDojo: false,
        useBuild: false,
        main: function () {
          require(["app/Class", "app/Bounds", "app/Visualization/Shader", "app/Data/TiledBinFormat"], function (Class, Bounds, Shader, TiledBinFormat) {

            function get_shader_program(gl) {
              return Shader.createShaderProgramFromSource(gl, $("#vertex-shader").text(), $("#fragment-shader").text(), "latitude");
            }

            function setupgl() {
              var canvas=$("#your_canvas")[0];
              canvas.width=window.innerWidth;
              canvas.height=window.innerHeight;

              try {
                var gl = canvas.getContext("experimental-webgl", {antialias: true});
              } catch (e) {
                alert("You are not webgl compatible :(") ;
                return false;
              } ;

              gl.canvas = canvas;

              gl.program = get_shader_program(gl);
              var _color = gl.getAttribLocation(gl.program, "color");
              var _position = gl.getAttribLocation(gl.program, "position");

              gl.enableVertexAttribArray(_color);
              gl.enableVertexAttribArray(_position);

              gl.useProgram(gl.program);

              return gl;
            }

            function draw_gl(gl, tileset) {

              var buffers = {};
              var tiles = tileset.getContent();

              var start = performance.now();
              tiles.map(function (tile) {
                buffers[tile.content.url] = {};
                Object.keys(tile.content.header.colsByName).map(function (name) {
                  buffers[tile.content.url][name] = gl.createBuffer();
                  Shader.programLoadArray(gl, buffers[tile.content.url][name], tile.content.data[name], gl.program);
                });
              });
              var end = performance.now();
              console.log("Load time: " + (end - start));


              gl.clearColor(0.0, 0.0, 0.0, 0.0);
              gl.viewport(0.0, 0.0, gl.canvas.width, gl.canvas.height);
              gl.clear(gl.COLOR_BUFFER_BIT);


              var start = performance.now();
              tiles.map(function (tile) {
                for (var name in buffers[tile.content.url]) {
                  Shader.programBindArray(gl, buffers[tile.content.url][name], gl.program, name, 1, gl.FLOAT);
                };

                for (var i = 0; i < tile.content.series.length - 1; i++) {
                  if (tile.content.series[i+1]-tile.content.series[i] > 0) {
                    gl.drawArrays(
                      gl.POINTS,
                      tile.content.series[i],
                      tile.content.series[i+1]-tile.content.series[i]
                    );
                  }
                }
              });
              var end = performance.now();

              console.log("Draw time: " + (end - start));

              gl.flush();
            };



            gl = setupgl();

            f = new TiledBinFormat({url:"/tile/test-grid"});

            f.tilesPerScreen = 128;

            f.events.on({
              header: function () {
                f.zoomTo(new Bounds(-180,-85,180,85));
              },
              update: function (e) {},
              all: function () {
                var end = performance.now();

                console.log("Number of tiles: " + f.getContent().length);
                console.log("Number of series: " + f.getContent().map(function (tile) { return tile.content.series.length - 1; }).reduce(function (a, b) { return a + b; }, 0));
                console.log("Number of points: " + f.getContent().map(function (tile) { return tile.content.header.length; }).reduce(function (a, b) { return a + b; }, 0));

                console.log("Fetch time: " + (end - start));

                draw_gl(gl, f);
              },
              error: function (e) {
                console.log("ERROR");
              }
            });

            var start = performance.now();

            f.load();
          });
        }
      };
    </script>
    <script type="text/javascript" src="js/deps.js"></script>
  </head>
  <body class="claro">
    <canvas id='your_canvas' style='position: absolute; background-color: black;'></canvas>
  </body>
</html>
true
